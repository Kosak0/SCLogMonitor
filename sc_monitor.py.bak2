#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Star Citizen Log Monitor - Versión Optimizada Integrada
Monitorea los logs de Star Citizen y proporciona información en tiempo real
"""

import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog
import sqlite3
import threading
import time
import json
import os
import sys
import logging
import re
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
import queue
import weakref
from contextlib import contextmanager

# Configuración de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('sc_monitor.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class ThemeManager:
    """Gestor de temas mejorado"""

    def __init__(self):
        self.current_theme = "dark"
        self.themes = {
            "dark": {
                "bg": "#2b2b2b",
                "fg": "#ffffff",
                "select_bg": "#404040",
                "select_fg": "#ffffff",
                "entry_bg": "#404040",
                "entry_fg": "#ffffff",
                "button_bg": "#505050",
                "button_fg": "#ffffff",
                "frame_bg": "#2b2b2b",
                "text_bg": "#1e1e1e",
                "text_fg": "#ffffff"
            },
            "light": {
                "bg": "#ffffff",
                "fg": "#000000",
                "select_bg": "#0078d4",
                "select_fg": "#ffffff",
                "entry_bg": "#ffffff",
                "entry_fg": "#000000",
                "button_bg": "#e1e1e1",
                "button_fg": "#000000",
                "frame_bg": "#f0f0f0",
                "text_bg": "#ffffff",
                "text_fg": "#000000"
            },
            "blue": {
                "bg": "#1e3a5f",
                "fg": "#ffffff",
                "select_bg": "#2d5aa0",
                "select_fg": "#ffffff",
                "entry_bg": "#2d5aa0",
                "entry_fg": "#ffffff",
                "button_bg": "#4a90e2",
                "button_fg": "#ffffff",
                "frame_bg": "#1e3a5f",
                "text_bg": "#0f2a4f",
                "text_fg": "#ffffff"
            }
        }
        self.registered_widgets = []

    def register_widget(self, widget, widget_type="default"):
        """Registra un widget para aplicar temas"""
        self.registered_widgets.append((weakref.ref(widget), widget_type))

    def set_theme(self, theme_name: str):
        """Cambia el tema actual"""
        if theme_name in self.themes:
            self.current_theme = theme_name
            self.apply_theme()
            logger.info(f"Tema cambiado a: {theme_name}")

    def get_theme_colors(self) -> Dict[str, str]:
        """Obtiene los colores del tema actual"""
        return self.themes.get(self.current_theme, self.themes["dark"])

    def apply_theme(self):
        """Aplica el tema actual a todos los widgets registrados"""
        colors = self.get_theme_colors()

        # Limpiar referencias muertas
        self.registered_widgets = [(ref, wtype) for ref, wtype in self.registered_widgets if ref() is not None]

        for widget_ref, widget_type in self.registered_widgets:
            widget = widget_ref()
            if widget is None:
                continue

            try:
                if widget_type == "text":
                    widget.configure(
                        bg=colors["text_bg"],
                        fg=colors["text_fg"],
                        insertbackground=colors["text_fg"]
                    )
                elif widget_type == "entry":
                    widget.configure(
                        bg=colors["entry_bg"],
                        fg=colors["entry_fg"],
                        insertbackground=colors["entry_fg"]
                    )
                elif widget_type == "button":
                    widget.configure(
                        bg=colors["button_bg"],
                        fg=colors["button_fg"]
                    )
                elif widget_type == "frame":
                    widget.configure(bg=colors["frame_bg"])
                else:
                    # Widget por defecto
                    widget.configure(
                        bg=colors["bg"],
                        fg=colors["fg"]
                    )
            except tk.TclError:
                # Algunos widgets no soportan todas las opciones
                pass

class DatabaseManager:
    """Gestor de base de datos optimizado"""

    def __init__(self, db_path: str = "sc_monitor.db"):
        self.db_path = db_path
        self.lock = threading.Lock()
        self._initialize_database()

    def _initialize_database(self):
        """Inicializa la base de datos con las tablas necesarias"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS log_entries (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                    log_type TEXT,
                    message TEXT,
                    player_name TEXT,
                    organization TEXT,
                    location TEXT,
                    processed BOOLEAN DEFAULT 0
                )
            ''')

            conn.execute('''
                CREATE TABLE IF NOT EXISTS players (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT UNIQUE,
                    organization TEXT,
                    first_seen DATETIME DEFAULT CURRENT_TIMESTAMP,
                    last_seen DATETIME DEFAULT CURRENT_TIMESTAMP,
                    encounter_count INTEGER DEFAULT 1
                )
            ''')

            # Crear índices para mejor rendimiento
            conn.execute('CREATE INDEX IF NOT EXISTS idx_log_timestamp ON log_entries(timestamp)')
            conn.execute('CREATE INDEX IF NOT EXISTS idx_player_name ON players(name)')
            conn.execute('CREATE INDEX IF NOT EXISTS idx_log_type ON log_entries(log_type)')

            conn.commit()

    def insert_log_entry(self, log_type: str, message: str, player_name: str = None, 
                        organization: str = None, location: str = None):
        """Inserta una entrada de log en la base de datos"""
        try:
            with self.lock:
                with sqlite3.connect(self.db_path) as conn:
                    conn.execute('''
                        INSERT INTO log_entries (log_type, message, player_name, organization, location)
                        VALUES (?, ?, ?, ?, ?)
                    ''', (log_type, message, player_name, organization, location))
                    conn.commit()
        except Exception as e:
            logger.error(f"Error insertando entrada de log: {e}")

class LogMonitor:
    """Monitor de logs optimizado"""

    def __init__(self, log_path: str, callback, db_manager: DatabaseManager):
        self.log_path = log_path
        self.callback = callback
        self.db_manager = db_manager
        self.running = False
        self.thread = None
        self.last_position = 0
        self.patterns = {
            'chat': re.compile(r'\[(.+?)\] (.+?): (.+)'),
            'player_join': re.compile(r'Player (.+?) joined'),
            'player_leave': re.compile(r'Player (.+?) left'),
            'location': re.compile(r'Location: (.+)'),
            'error': re.compile(r'ERROR|FATAL|CRITICAL', re.IGNORECASE),
            'warning': re.compile(r'WARNING|WARN', re.IGNORECASE)
        }

    def start_monitoring(self):
        """Inicia el monitoreo del archivo de log"""
        if not self.running:
            self.running = True
            self.thread = threading.Thread(target=self._monitor_loop, daemon=True)
            self.thread.start()
            logger.info("Monitoreo de logs iniciado")

    def stop_monitoring(self):
        """Detiene el monitoreo del archivo de log"""
        self.running = False
        if self.thread and self.thread.is_alive():
            self.thread.join(timeout=2)
        logger.info("Monitoreo de logs detenido")

    def _monitor_loop(self):
        """Bucle principal de monitoreo"""
        while self.running:
            try:
                if os.path.exists(self.log_path):
                    self._process_log_file()
                time.sleep(1)  # Intervalo de verificación
            except Exception as e:
                logger.error(f"Error en el bucle de monitoreo: {e}")
                time.sleep(5)  # Esperar más tiempo en caso de error

    def _process_log_file(self):
        """Procesa el archivo de log"""
        try:
            with open(self.log_path, 'r', encoding='utf-8', errors='ignore') as file:
                file.seek(self.last_position)
                new_lines = file.readlines()
                self.last_position = file.tell()

                for line in new_lines:
                    self._process_line(line.strip())

        except Exception as e:
            logger.error(f"Error procesando archivo de log: {e}")

    def _process_line(self, line: str):
        """Procesa una línea del log"""
        if not line:
            return

        log_entry = {
            'timestamp': datetime.now(),
            'raw_line': line,
            'type': 'info',
            'player': None,
            'organization': None,
            'message': line
        }

        # Detectar tipo de mensaje
        if self.patterns['error'].search(line):
            log_entry['type'] = 'error'
        elif self.patterns['warning'].search(line):
            log_entry['type'] = 'warning'
        elif self.patterns['chat'].search(line):
            log_entry['type'] = 'chat'
            # Extraer información del chat
            match = self.patterns['chat'].search(line)
            if match:
                log_entry['player'] = match.group(2)
                log_entry['message'] = match.group(3)

        # Guardar en base de datos
        self.db_manager.insert_log_entry(
            log_entry['type'],
            log_entry['message'],
            log_entry['player'],
            log_entry['organization']
        )

        # Callback para actualizar UI
        if self.callback:
            self.callback(log_entry)

class ConfigManager:
    """Gestor de configuración mejorado"""

    def __init__(self, config_file: str = "sc_monitor_config.json"):
        self.config_file = config_file
        self.config = self._load_default_config()
        self.load_config()

    def _load_default_config(self) -> Dict[str, Any]:
        """Carga la configuración por defecto"""
        return {
            "current_user": "",
            "log_filename": "",
            "crew_nicks": [],
            "players_blacklist": [],
            "players_whitelist": [],
            "orgs_blacklist": [],
            "orgs_whitelist": [],
            "auto_start": False,
            "save_position": True,
            "show_direction": True,
            "web_info": True,
            "transparency": 1.0,
            "font_size": 11,
            "overlay_position": "top",
            "window_geometry": "800x600",
            "overlay_geometry": "800x120",
            "theme": "dark"
        }

    def load_config(self):
        """Carga la configuración desde el archivo"""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    loaded_config = json.load(f)
                    # Fusionar con configuración por defecto
                    self._merge_config(self.config, loaded_config)
                logger.info("Configuración cargada exitosamente")
            else:
                self.save_config()  # Crear archivo de configuración por defecto
        except Exception as e:
            logger.error(f"Error cargando configuración: {e}")

    def _merge_config(self, default: Dict, loaded: Dict):
        """Fusiona configuración cargada con la por defecto"""
        for key, value in loaded.items():
            if key in default:
                if isinstance(value, dict) and isinstance(default[key], dict):
                    self._merge_config(default[key], value)
                else:
                    default[key] = value
            else:
                default[key] = value

    def save_config(self):
        """Guarda la configuración actual"""
        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
            logger.info("Configuración guardada exitosamente")
        except Exception as e:
            logger.error(f"Error guardando configuración: {e}")

    def get(self, key: str, default=None):
        """Obtiene un valor de configuración"""
        keys = key.split('.')
        value = self.config
        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                return default
        return value

    def set(self, key: str, value):
        """Establece un valor de configuración"""
        keys = key.split('.')
        config = self.config
        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]
        config[keys[-1]] = value

class StarCitizenMonitor:
    """Aplicación principal del monitor de Star Citizen"""

    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Star Citizen Monitor - Optimizado")
        self.root.geometry("1200x800")

        # Inicializar componentes
        self.config_manager = ConfigManager()
        self.theme_manager = ThemeManager()
        self.db_manager = DatabaseManager("sc_monitor.db")
        self.log_monitor = None

        # Variables de UI
        self.log_queue = queue.Queue()
        self.is_monitoring = False

        # Configurar tema inicial
        initial_theme = self.config_manager.get("theme", "dark")
        self.theme_manager.set_theme(initial_theme)

        # Crear interfaz
        self._create_ui()
        self._setup_bindings()

        # Configurar actualización de UI
        self.root.after(100, self._update_ui)

        logger.info("Star Citizen Monitor iniciado")

    def _create_ui(self):
        """Crea la interfaz de usuario"""
        # Frame principal
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Toolbar
        self._create_toolbar(main_frame)

        # Panel de configuración
        self._create_config_panel(main_frame)

        # Panel de logs
        self._create_log_panel(main_frame)

        # Barra de estado
        self._create_status_bar(main_frame)

    def _create_toolbar(self, parent):
        """Crea la barra de herramientas"""
        toolbar_frame = ttk.Frame(parent)
        toolbar_frame.pack(fill=tk.X, pady=(0, 5))

        # Botones principales
        self.start_button = ttk.Button(toolbar_frame, text="Iniciar", command=self._toggle_monitoring)
        self.start_button.pack(side=tk.LEFT, padx=(0, 5))

        ttk.Button(toolbar_frame, text="Limpiar Logs", command=self._clear_logs).pack(side=tk.LEFT, padx=(0, 5))

        # Selector de tema
        ttk.Label(toolbar_frame, text="Tema:").pack(side=tk.RIGHT, padx=(5, 0))
        self.theme_var = tk.StringVar(value=self.theme_manager.current_theme)
        theme_combo = ttk.Combobox(toolbar_frame, textvariable=self.theme_var, 
                                  values=list(self.theme_manager.themes.keys()),
                                  state="readonly", width=10)
        theme_combo.pack(side=tk.RIGHT, padx=(5, 0))
        theme_combo.bind('<<ComboboxSelected>>', self._on_theme_change)

    def _create_config_panel(self, parent):
        """Crea el panel de configuración"""
        config_frame = ttk.LabelFrame(parent, text="Configuración")
        config_frame.pack(fill=tk.X, pady=(0, 5))

        # Ruta del archivo de log
        ttk.Label(config_frame, text="Archivo de Log:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=2)
        self.log_path_var = tk.StringVar(value=self.config_manager.get("log_filename", ""))
        log_path_entry = ttk.Entry(config_frame, textvariable=self.log_path_var, width=60)
        log_path_entry.grid(row=0, column=1, padx=5, pady=2, sticky=tk.EW)
        ttk.Button(config_frame, text="Examinar", command=self._browse_log_file).grid(row=0, column=2, padx=5, pady=2)

        # Usuario actual
        ttk.Label(config_frame, text="Usuario:").grid(row=1, column=0, sticky=tk.W, padx=5, pady=2)
        self.user_var = tk.StringVar(value=self.config_manager.get("current_user", ""))
        ttk.Entry(config_frame, textvariable=self.user_var, width=20).grid(row=1, column=1, padx=5, pady=2, sticky=tk.W)

        config_frame.columnconfigure(1, weight=1)

    def _create_log_panel(self, parent):
        """Crea el panel de logs"""
        log_frame = ttk.LabelFrame(parent, text="Logs en Tiempo Real")
        log_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 5))

        # Área de texto para logs
        self.log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, height=20)
        self.log_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Registrar para temas
        self.theme_manager.register_widget(self.log_text, "text")

        # Panel de filtros
        filter_frame = ttk.Frame(log_frame)
        filter_frame.pack(fill=tk.X, padx=5, pady=(0, 5))

        self.filter_vars = {}
        filters = ["Info", "Warning", "Error", "Chat"]
        for i, filter_name in enumerate(filters):
            var = tk.BooleanVar(value=True)
            self.filter_vars[filter_name.lower()] = var
            ttk.Checkbutton(filter_frame, text=filter_name, variable=var).pack(side=tk.LEFT, padx=5)

    def _create_status_bar(self, parent):
        """Crea la barra de estado"""
        self.status_var = tk.StringVar(value="Listo")
        status_bar = ttk.Label(parent, textvariable=self.status_var, relief=tk.SUNKEN)
        status_bar.pack(fill=tk.X, side=tk.BOTTOM)

    def _setup_bindings(self):
        """Configura los eventos y bindings"""
        self.root.protocol("WM_DELETE_WINDOW", self._on_closing)

        # Guardar configuración al cambiar valores
        self.log_path_var.trace('w', self._on_config_change)
        self.user_var.trace('w', self._on_config_change)

    def _on_theme_change(self, event=None):
        """Maneja el cambio de tema"""
        new_theme = self.theme_var.get()
        self.theme_manager.set_theme(new_theme)
        self.config_manager.set("theme", new_theme)
        self.config_manager.save_config()

    def _on_config_change(self, *args):
        """Maneja cambios en la configuración"""
        self.config_manager.set("log_filename", self.log_path_var.get())
        self.config_manager.set("current_user", self.user_var.get())

    def _browse_log_file(self):
        """Abre el diálogo para seleccionar archivo de log"""
        filename = filedialog.askopenfilename(
            title="Seleccionar archivo de log de Star Citizen",
            filetypes=[("Log files", "*.log"), ("All files", "*.*")]
        )
        if filename:
            self.log_path_var.set(filename)

    def _toggle_monitoring(self):
        """Inicia o detiene el monitoreo"""
        if not self.is_monitoring:
            log_path = self.log_path_var.get()
            if not log_path or not os.path.exists(log_path):
                messagebox.showerror("Error", "Por favor selecciona un archivo de log válido")
                return

            self.log_monitor = LogMonitor(log_path, self._on_log_entry, self.db_manager)
            self.log_monitor.start_monitoring()
            self.is_monitoring = True
            self.start_button.config(text="Detener")
            self.status_var.set("Monitoreando...")

        else:
            if self.log_monitor:
                self.log_monitor.stop_monitoring()
            self.is_monitoring = False
            self.start_button.config(text="Iniciar")
            self.status_var.set("Detenido")

    def _on_log_entry(self, log_entry):
        """Maneja nuevas entradas de log"""
        self.log_queue.put(log_entry)

    def _update_ui(self):
        """Actualiza la interfaz de usuario"""
        # Procesar entradas de log en cola
        try:
            while True:
                log_entry = self.log_queue.get_nowait()
                self._display_log_entry(log_entry)
        except queue.Empty:
            pass

        # Programar siguiente actualización
        self.root.after(100, self._update_ui)

    def _display_log_entry(self, log_entry):
        """Muestra una entrada de log en la interfaz"""
        entry_type = log_entry.get('type', 'info')

        # Verificar filtros
        if not self.filter_vars.get(entry_type, tk.BooleanVar(value=True)).get():
            return

        # Formatear mensaje
        timestamp = log_entry['timestamp'].strftime("%H:%M:%S")
        message = f"[{timestamp}] [{entry_type.upper()}] {log_entry['message']}\n"

        # Insertar en el área de texto
        self.log_text.insert(tk.END, message)

        # Auto-scroll
        self.log_text.see(tk.END)

        # Limitar número de líneas
        lines = int(self.log_text.index('end-1c').split('.')[0])
        if lines > 1000:
            self.log_text.delete('1.0', f'{lines - 1000}.0')

    def _clear_logs(self):
        """Limpia el área de logs"""
        self.log_text.delete('1.0', tk.END)

    def _on_closing(self):
        """Maneja el cierre de la aplicación"""
        if self.is_monitoring and self.log_monitor:
            self.log_monitor.stop_monitoring()

        # Guardar configuración
        self.config_manager.save_config()

        self.root.destroy()
        logger.info("Aplicación cerrada")

    def run(self):
        """Ejecuta la aplicación"""
        try:
            self.root.mainloop()
        except Exception as e:
            logger.error(f"Error fatal en la aplicación: {e}")
            messagebox.showerror("Error Fatal", f"Error inesperado: {e}")

def main():
    """Función principal"""
    try:
        app = StarCitizenMonitor()
        app.run()
    except Exception as e:
        logger.error(f"Error fatal: {e}")
        print(f"Error fatal: {e}")

if __name__ == "__main__":
    main()
